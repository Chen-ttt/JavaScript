<!--
 * @Description:
 * @Author: Tong Chen
 * @Date: 2022-09-27 21:46:55
 * @LastEditTime: 2022-09-30 14:06:44
 * @LastEditors:
-->

# 美团

## 一面

1. 介绍项目, 项目里有什么优化的地方 (useMemo, 图片懒加载)

2. 为什么用 Redux, Redux 和 Mobx 区别
   https://github.com/Chen-ttt/JavaScript/blob/master/interview/t.md

3. Commonjs

- 每个脚本文件就是一个模块, 有自己的作用域
- 每个模块内部, module 变量代表当前模块, 是一个对象; module.exports 属性表示当前模块对外输出的接口, 其他文件加载该模块, 实际上是读取 module.exports 变量
- 另外, Node 为每个模块提供一个 exports 变量, 指向 module.exports

```
const a = 0

// 1. 依次导出
module.exports.a = a
exports.a = a // exports默认指向module.exports

// 2. 整体导出
module.exports = { a }
```

- require 命令用于加载模块文件, 第一次加载脚本文件时就会执行整个脚本, 并在内存中生成一个该模块的说明对象, 引用该模块的其他文件都会到 exports 属性中取值; 且即使再次用 require 加载该模块, 它的脚本文件也不会再次执行, 而是到缓存中去取值

```
{
  id: '',
  exports: { // 模块输出的各个接口
    ...
  },
  filename: './path/subpath/file.js', // 当前模块的绝对路径
  loaded: true, // 脚本是否执行完毕
  children: [], // 被该模块引用的模块
  parent: '', // 第一个引用该模块的模块
  paths: [ // 模块的搜索路径
    '/path/a/node_modules',
    '/path/b/node_modules',
    '/path/node_modules',
    '/node_modules',
    ...
  ]
}
```

4. ES6 Module

- 使用静态语法, 且 export 和 import 只能出现在代码顶层
- 存在 import 提升, 且只会在第一次加载时运行, 之后的重复加载都不会运行
- 数据是动态绑定的

```
const a = 0

// 1
export { a }

// 2
export const a = 0

// 3. 默认导出 - 实际上是设置一个名为default的接口
export default a
```

```
// 导出
import { a } from ...
import { a as A} from ...
import * as A from ...

// 导入默认接口
import A from ...
```

5. Commonjs 和 ES6 导入模块区别

- Commonjs 的 require 命令是同步执行的, 因此只有加载完成才执行后面的操作 (因此 Commonjs 服务端, 如果用于前端的话, 加载过程会造成一段时间的白屏)
  而 ES6 是异步的, 可以用于客户端或服务端, 且在 node 中使用 ES6 时, 需要将遵循 ES6 Module 的文件写为以.mjs 为后缀的文件

- Commonjs 输出的是值的拷贝, 即原来模块中的值 和 已经加载完毕的值不会相互影响
  ES6 Module 是静态分析, 动态引用, 加载的是值的引用, 即原来模块中的值 和 已经加载完毕的值指向同一块内存, 会相互影响, 一方改变, 另一方也改变

- Commonjs 的模块是运行时加载, 因此不存在 require 提升
  ES6 模块是静态编译时就确定了模块的依赖, 存在 import 提升

- Commonjs 加载的是整个模块, 所有的接口全部加载
  ES6 可以只加载其中的某个接口(方法)

- Commonjs 中顶层的 this 指向当前模块
  ES6 模块中的顶层 this 指向 undefined

6. 为什么用 indexedDB ? 和前端其他储存相比, 有什么区别 (cookie / sessionStorage / localStorage)

- https://github.com/Chen-ttt/JavaScript/tree/master/interview

7. 解释进程线程, 进程之间如何通信

- 进程

  > - 系统进行资源分配和调度的最小单位, 是程序的实体, 一个程序运行就是一个进程
  > - 进程拥有自己独占的虚拟地址空间, CPU 通过地址翻译将虚拟地址转换为真实的物理地址; 每个进程只能访问自己的地址空间, 因此在没有其他机制的辅助下, 进程之间是无法进行通信的
  > - 系统为每一个进程分配一个进程控制块 PCB (Processing Control Block), 用于对进程的管理的控制

- 线程

  > - 程序执行中处理器 CPU 调度和分派的最小单元
  > - 同一个进程的多个线程共享该进程的全部系统资源, 如虚拟地址空间、文件描述符等等, 因此需要考虑同步、互斥操作
  > - 但他们又有各自的调用栈和线程本地储存
  > - 系统为每一个线程分配一个线程控制块 TCB (Thread Control Block)

- 如何通信

  - 管道
  - 消息队列
  - 共享内存
  - 信号量

    > 本质上是一个整型的计数器, 实现进程之间的互斥和同步
    >
    > - P 操作: 信号量 - 1, 相减后若信号量小于 0, 则表示资源已被占用, 进程需要阻塞等待; 如果大于等于 0, 表示还有资源可用, 进程可以正常执行
    > - V 操作: 信号量 + 1, 相加后若信号量小于等于 0, 则表示当前有进程正在阻塞, 会将该进程唤醒; 如果大于 0, 则表示当前没有阻塞的进程
    >
    > - 信号量实现互斥
    > - 信号量实现同步

  - Socket - 可以实现同一主机、跨主机、跨网络的进程间通信

    1. 针对 TCP 的 Socket 通信:
       ![Socket](https://img-blog.csdnimg.cn/img_convert/a3e2fc90ff95c6d5546b8b1b7b06dcb3.png)

       > - 服务端和客户端初始化 Socket，得到文件描述符
       > - 服务端调用 bind，绑定 IP 和端口 - 服务端调用 listen，进行监听
       > - 服务端调用 accept，等待客户端连接
       > - 客户端调用 connect，向服务端发起连接请求。（TCP 三次握手）
       > - 服务端调用 accept 返回用于传输的 Socket 的文件描述符（和第一点得到的 Socket 不同）
       > - 客户端使用 write 写入数据，服务端调用 read 读取数据
       > - 客户端断开连接时会调用 close，服务端也会调用 close（TCP 四次挥手）

    2. 针对 UDP 的 Socket 通信:
       ![Socket](https://img-blog.csdnimg.cn/img_convert/3b3e274d2c58f8477a962d18e4d341fc.png)

8. Node 和其他后端语言(C/Java/Python)相比有什么区别

- Node 基于 js 语言, 在实现 web 项目时有极大优势, 不需要像 PHP 一样, 额外搭建 Nginx 的 http 服务器来响应客户端操作, 只需要几行代码就可以搭建 http 服务器并发送请求
- Node 和前端 js 代码属于同一套体系, 配合方便, 便于代码整合
- 遵循事件驱动的非阻塞 I/O 模型, 遵循异步机制, 因此在高并发场景下表现优秀
  - 异步地处理事件, 不会阻塞之后的操作; 对每个新连接都发射(emit)一个运行的时间(event), 并放入时间队列中, 而不是为其分配一个新的 OS 线程; 并在事件完成后执行相应的回调
  - 以非阻塞的方式处理输入/输出(I/O); 每遇到一个 I/O 事件就创建一个线程去执行, 然后主线程会继续执行下去; 等该事件完成之后会执行相应的回调

9. JS 是多线程还是单线程 ? JS 引擎解析 JS 代码的过程

10. JS 语言和 C 语言的区别, 谁更快, 为什么

- C 会被编译成机器语言, 编译后产生可执行文件, 此后如果重复运行, 就不需要再次编译, 只运行可执行文件就行, 读取可执行文件中的机器码会非常快; 而 JS 是脚本语言, 每次运行都会重新编译并逐行解释
- C 需要开发人员手动管理内存, 而 JS 的内存由解释器管理
- C 是静态类型语言, 每个变量的数据类型在运行前就已确定, 不能再更改; 而 JS 是动态类型语言, 数据类型在运行时可以不断变化
- C 语言没有闭包的概念
- C 可以通过调用系统 API 实现多线程; 而 JS 是单线程, 具有事件循环机制, 可能阻塞的操作都由 JS 运行时提供的异步 API 来完成
- C 面向过程; JS 可以通过原型链和闭包来实现面向对象 (类的继承、多态等等)

**C 更快, 原因在于前两点区别**

11. TCP 流量控制 & 拥塞控制

流量控制是用作于接收者的, 将控制发送者的数据发送量, 而拥塞控制是作用于网络的, 防止过多的数据注入网络, 避免出现网络负载过大的情况。

- 流量控制

  - 让发送方根据接收端实际的接受能力 来控制发送的数据量
  - 通过滑动窗口实现
    > - TCP 协议的 header 中, 有一个 16 位的窗口大小的字段, 表示接收端这边的接收数据缓冲区的剩余大小
    > - 该值越大, 证明接收端的缓冲区剩余空间越大, 网络的吞吐量就越大
    > - 当接收端面临数据溢出时, 该值会被设置为更小的值, 于是发送方会对发送的数据量做出调整, 从而形成流量控制

- 拥塞控制

  - 网络中的资源是有限的, 当其中的某个设备(例如路由器)接收的数据包超过数据包处理队列的长度, 就会无条件的丢弃接下来新接收到的数据包, 那么此时上层的 TCP 协议会以为发生了丢包, 而重传它们, 此时路由器又会丢弃, 如此以往, 网络性能将急剧下降

  - 因此发送方维护一个拥塞窗口, 其大小取决于网络的拥塞程度, 且在动态变化; 发送窗口的大小 取拥塞窗口和接收端窗口的最小值
  - 如何确定拥塞窗口大小 ?
    > - 慢启动算法
    >   不要一开始就发送大量数据, 由小到大地增加拥塞窗口的大小, 每个轮次翻倍
    > - 拥塞避免算法
        使拥塞窗口的大小线性增加
    > - 配合使用
    >
    > > 当 cwnd < ssthresh 时，使用慢开始算法。
    > > 当 cwnd > ssthresh 时，改用拥塞避免算法。
    > > 当 cwnd = ssthresh 时，慢开始与拥塞避免算法随机

12. HTTP 劫持 & HTTPS 如何保证安全通信 & 为什么要先非对称加密再对称加密, 为什么不只使用一种

- HTTP 劫持: 在服务器返回数据的过程中拦截数据, 在其中插入恶意数据或直接回传虚假数据, 那么浏览器将得到错误的响应信息; 常见的例子是 在网页中插入广告或弹窗
- DNS 劫持: 过程类似, 指直接篡改 ip 地址, 让用户去访问其他网页, 或者直接劫持响应包, 不予回应

- 解决: HTTPS (HTTP + SSL/TLS)

  > 1. 客户端发起 HTTPS 请求到服务器的 443 端口, 和 HTTP 一样需要三次握手
  > 2. 服务端向客户端发送 CA 数字证书, 包含公钥、证书颁发者、到期日期; 服务器拥有加密钥匙对, 即公钥和私钥, 公钥用于加密, 私钥用于解密, 服务端会保留私钥, 将公钥放入 CA 中
  > 3. 客户端收到证书, 会验证证书的有效性
  > 4. 若有效, 则生成一个随机码, 再用公钥将其加密, 最后发送给服务器端
  > 5. 服务器收到后, 用私钥进行解密, 得到随机码
  > 6. 此后这个随机码将作为主密钥, 所有通信都将被主密钥加密

!!! 注意: 在前期证书验证阶段是**非对称加密**, 而之后的内容传输是**对称加密**

- 为什么要先非对称加密再对称加密, 为什么不只使用一种 ?
  - 非对称加密是为了获得统一的主密钥, 这种方式更加安全 (就算主钥在传输过程中被窃取, 没有私钥也无法得到主密钥)
  - 对称加密是为了之后的通信, 以为非对称加密的加密效率非常低, 在大量数据通信的场景下, 其效率是无法接受的

13. 看代码说输出
    https://github.com/Chen-ttt/JavaScript/blob/master/interview/console.js

14. 代码: 写一个防抖函数

15. 说一下数组和链表的区别

16. 代码: 旋转链表
    https://github.com/Chen-ttt/JavaScript/blob/master/interview/rotateLinkedList.js
